<!DOCTYPE html>
<html>
<head>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        img {
        max-width: 600px;
        height: auto;      
        display: block;    
        margin: 10px 0;  
        }
    </style>
</head>
<body>
    <p>Project 2</p>
    <br>
    <br>
    <p>Part 1: Filters and Edges</p>
    <br>
    <p>Part 1.1: Convolutions from Scratch!</p>
    <br>
    <img src="./media/four_loop_convolve.png">
    <img src="./media/two_loop_convolve.png">
    <br>
    <p>In terms of correctness, the four loop, two loop, and scipy.signal.convolve2d approaches are equivalent. For runtime rankings, the slowest to fastest is the four loop, two loop, and then scipy. The four loop is slowest because it does every element wise multiplication. The two loop is faster because it uses vectorized operations in NumPy. SciPy.signal.convolve2d is the fastest because it is an optimized Scipy function. The boundaries are handled in the same manner with similar padding schemes.</p>
    <br>
    <br>
    <p>Part 1.2: Finite Difference Operator</p>
    <br>
    <img src="./media/partial_derivative.png">
    <img src="./media/grad_magnitude.png">
    <br>
    <p>All edges could be found with the lower threshold of the mean + one standard deviation. However, this left behind lots of noise. The higher threshold was the mean + two standard deviations but this didn't fully show some of the real edges. The threshold I ended up settling for was the mean + 1.7 standard deviations. This threshold fully displayed the significant edges and took away majority of the noise. </p>
    <br>
    <br>
    <p>Part 1.3: Derivative of Gaussian (DoG) Filter</p>
    <br>
    <img src="./media/gaussian_smoothing.png">
    <img src="./media/dog_filter.png">
    <br>
    <p>The gradient magnitude image with the Gaussian filter takes out all of the noise. Whereas, the gradient magnitude on the regular image contains lot of noise.</p>
    <br>
    <br>
    <p>Part 2: Fun with Frequencies!</p>
    <br>
    <p>Part 2.1: Image "Sharpening"</p>
    <br>
    <img src="./media/taj_mahal.png">
    <br>
    <p>The unsharp mask filter is equivalent to adding the original image and a factor alpha times the high frequencies. The high frequencies can be found by subtracting the original image and the blurred image.</p>
    <br>
    <img src="./media/colosseum.png">
    <img src="./media/colosseum_sharpened.png">
    <br>
    <br>
    <p>Part 2.2: Hybrid Images</p>
    <br>
    <img src="./media/orig_and_aligned.png">
    <img src="./media/fft1.png">
    <img src="./media/fft2.png">
    <img src="./media/filtered_img.png">
    <img src="./media/hybrid.png">
    <br>
    <img src="./media/hybrid2.png">
    <img src="./media/hybrid3.png">
    <br>
    <br>
    <p>Part 2.3: Gaussian and Laplacian Stacks + Part 2.4: Multiresolution Blending (a.k.a. the oraple!)</p>
    <br>
    <img src="./media/stacks.png">
    <img src="./media/blended1.png">
    <img src="./media/blended2.png">
    <img src="./media/blended3.png">
    

   
   
</body>
</html>